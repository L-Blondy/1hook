---
title: useContextualState
description: useState with a context.
---

```package-install
npm install @1hook/use-contextual-state
```

## Quick Start

<Steps>
<Step>
### Define the hook

Pass the state **type** to `defineContextualState` to ensure type safety throughout your application.

```tsx twoslash title="use-count.ts" include use-count
import { defineContextualState } from '@1hook/use-contextual-state'

export const [CountProvider, useCount] = defineContextualState<number>()
```

</Step>
<Step>
### Place the Provider

Place the Provider in your component tree and initialize the state by passing `initialValues` to the provider.

```tsx twoslash
// @noErrors
// @include: use-count
// ---cut---
import { CountProvider } from './use-count'

function Providers(props: { children: ReactNode }) {
  return <CountProvider initialState={0}>{props.children}</CountProvider>
}
```

</Step>
<Step>
### Use the state like `useState`

```tsx twoslash
// @include: use-count
// ---cut---
const [count, setCount] = useCount()
```

</Step>
</Steps>

For improved performance, `defineContextualState` provides a `useSetState` hook. \
It helps prevent unnecessary rerenders by not listening to the state.

```tsx title='count.ts'
import { defineContextualState } from '@1hook/use-contextual-state'

export const [CountProvider, useCount, useSetCount] =
  defineContextualState<number>()
```

The component does not rerender when count changes:

```tsx
import { useSetCount } from './count'

function Increment() {
  const setCount = useSetCount()

  return (
    <button onClick={() => setCount((count) => count + 1)}>Increment</button>
  )
}
```
